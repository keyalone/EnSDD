#' This function is designed for the clustering the spots based on the spots-spots similarity
#'
#' The function is based on the non-spatial clustering method, Louvain's algorithm but with adaptive resolution setting
#'
#' @importFrom igraph graph_from_adjacency_matrix membership cluster_louvain
#'
#' @param Seurat.data the Seurat object generated by data_process.
#' @param similarity_mat a spots similarity matrix.
#' @param setting_k the number of clustering setting by users.
#' @param resolution_louvain setting the resolution for the algorithm. Provided by the user. Default setting is NULL.
#' @param min.res minimal resolution using for the selection of optimal resolution in binary search process. Default setting is 0.05.
#' @param max.res maximal resolution using for the selection of optimal resolution in binary search process. Default setting is 5.
#' @param max_step the maximal step for the search of resolution in Louvain algorithm.
#' @param tolerance the difference between ideal number of clusters and identified number of clusters. Default setting is 0.
#'
#'
#' @export
#'
Louvain_clustering_binary <- function(Seurat.data, similarity_mat, setting_k = 7,
                                      resolution_louvain = NULL, min.res = 0.05,
                                      max.res = 5, max_step = 50, tolerance = 0){
  if(! isSymmetric(similarity_mat))
    stop("The constructed similarity matrix need be symmetric...")
  # res_all <- seq(0.02, max.res, increase)

  net <- igraph::graph_from_adjacency_matrix(similarity_mat, mode = "undirected", weighted = TRUE)
  if(is.null(resolution_louvain)){
    this_step = 0
    this_min = as.numeric(min.res)
    this_max = as.numeric(max.res)

    while(this_step < max_step){
      this_resolution = this_min + ((this_max-this_min)/2)
      louvain_cluster.temp <- igraph::cluster_louvain(net, resolution = this_resolution)
      res <- igraph::membership(louvain_cluster.temp)
      this_cluster = length(levels(as.factor(res)))
      message(paste0("Step K: ", this_step,
                     " Louvain resolution: ", this_resolution,
                     " Number of clusters: ", this_cluster,
                     " Ideal of clusters: ", setting_k))
      if(this_cluster > setting_k+tolerance){
        this_max = this_resolution
      }else if(this_cluster < setting_k-tolerance){
        this_min = this_resolution
      }else{
        print(paste0('Succeed to find clusters: ', setting_k,
                     ' and resolution equal: ', this_resolution))
        break
      }
      this_step = this_step + 1
    }

    if(this_step >= max_step){
      print('Cannot find the number of clusters.')
    }
  }

  if(!is.null(resolution_louvain)){
    louvain_cluster <- igraph::cluster_louvain(net, resolution = resolution_louvain)
    res <- igraph::membership(louvain_cluster)
  }

  res.final <- res
  names(res.final) <- colnames(similarity_mat)
  return(res.final)

}

# Louvain_clustering_binary_opt <- function(Seurat.data, similarity_mat, setting_k = 7,
#                                           resolution_louvain = NULL, min.res = 0.05,
#                                           rep_times = 10,max.res = 5, max_step = 50,
#                                           tolerance = 0){
#   if(! isSymmetric(similarity_mat))
#     stop("The constructed similarity matrix need be symmetric...")
#   # res_all <- seq(0.02, max.res, increase)
#
#   net <- igraph::graph_from_adjacency_matrix(similarity_mat, mode = "undirected", weighted = TRUE)
#
#   cluster_res <- list()
#   modality_res <- c()
#   for (i in 1:rep_times) {
#     cat(paste0('Rep times:', i), '\n')
#
#     if(is.null(resolution_louvain)){
#       this_step = 0
#       this_min = as.numeric(min.res)
#       this_max = as.numeric(max.res)
#
#       while(this_step < max_step){
#         this_resolution = this_min + ((this_max-this_min)/2)
#         louvain_cluster.temp <- igraph::cluster_louvain(net, resolution = this_resolution)
#         modularities <- igraph::modularity(louvain_cluster.temp)
#         res <- igraph::membership(louvain_cluster.temp)
#         this_cluster = length(levels(as.factor(res)))
#         message(paste0("Step K: ", this_step,
#                        " Louvain resolution: ", this_resolution,
#                        " Number of clusters: ", this_cluster,
#                        " Ideal of clusters: ", setting_k))
#         if(this_cluster > setting_k+tolerance){
#           this_max = this_resolution
#         }else if(this_cluster < setting_k-tolerance){
#           this_min = this_resolution
#         }else{
#           print(paste0('Succeed to find clusters: ', setting_k,
#                        ' and resolution equal: ', this_resolution))
#           break
#         }
#         this_step = this_step + 1
#       }
#
#       if(this_step >= max_step){
#         print('Cannot find the number of clusters.')
#       }
#     }
#     if(!is.null(resolution_louvain)){
#       louvain_cluster <- igraph::cluster_louvain(net, resolution = resolution_louvain)
#       modularities <- igraph::modularity(louvain_cluster)
#       res <- igraph::membership(louvain_cluster)
#     }
#
#     cluster_res[[i]] <- res
#     modality_res <- c(modality_res, modularities)
#   }
#
#   best_run <- which.max(modality_res)
#   res.final <- cluster_res[[best_run]]
#   # res.final <- res
#   names(res.final) <- colnames(similarity_mat)
#   # res.final.list <- list(cluster_res = cluster_res,
#   #                        modality_res = modality_res)
#   return(res.final)
#   # return(res.final.list)
# }

